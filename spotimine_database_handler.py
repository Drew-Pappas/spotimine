import sqlite3
import plotly.graph_objs as go
import json
import datetime

# CONSTANTS # 
CACHE_FILE_NAME = 'cache.json'
CACHE_DICT = {}

def create_database():
    '''Creates a sqlite db if it does not exist
    
    Parameters
    ----------
    none

    Returns
    ----------
    none
    '''

    conn = sqlite3.connect("spotimine.sqlite")
    conn.commit()
    conn.close()

def create_tables():
    '''Creates sqlite tables if they do not exist
    
    Parameters
    ----------
    none

    Returns
    ----------
    none
    '''

    create_tracks = '''
    CREATE TABLE IF NOT EXISTS "Tracks" (
        "Id" INTEGER PRIMARY KEY AUTOINCREMENT UNIQUE,
        "Name" TEXT NOT NULL,
        "Popularity"  INTEGER NOT NULL,
        "SpotifyId" TEXT,
        FOREIGN KEY(SpotifyId) REFERENCES AudioFeatures(Id)
    );
    '''
    create_audio_features = '''
    CREATE TABLE IF NOT EXISTS "AudioFeatures" (
        "Id"        TEXT PRIMARY KEY UNIQUE,
        "DurationMS"        INTEGER NOT NULL,
        "Key"        INTEGER NOT NULL,
        "Mode"        INTEGER NOT NULL,
        "TimeSignature"        INTEGER NOT NULL,
        "Acousticness"        REAL NOT NULL,
        "Danceability"        REAL NOT NULL,
        "Energy"        REAL NOT NULL,
        "Instrumentalness"        REAL NOT NULL,
        "Liveness"        REAL NOT NULL,
        "Loudness"        REAL NOT NULL,
        "Speechiness"        REAL NOT NULL,
        "Valence"        REAL NOT NULL,
        "Tempo"        REAL NOT NULL
        
    );
    '''
    conn = sqlite3.connect("spotimine.sqlite")
    cur = conn.cursor()
    cur.execute(create_tracks)
    cur.execute(create_audio_features)
    conn.commit()
    conn.close()


def drop_tables():
    '''Drops sqlite tables if they exist
    
    Parameters
    ----------
    none

    Returns
    ----------
    none
    '''

    conn = sqlite3.connect("spotimine.sqlite")
    cur = conn.cursor()
    drop_tracks = '''
    DROP TABLE IF EXISTS "Tracks";
    '''
    drop_audio_features = '''
    DROP TABLE IF EXISTS "AudioFeatures"
    '''
    cur.execute(drop_tracks)
    cur.execute(drop_audio_features)
    conn.commit()
    conn.close()


def add_to_db(records, kind):
    '''Adds records to a sqlite db
    Parameters
    ----------
    records : list
        list of tuples containing records to be inserted
    kind : str
        the kind of record that determines which table to insert to

    Returns
    -------
    none
    '''

    if kind == "track":
        statement = "Tracks (Name, Popularity, SpotifyId) VALUES (?,?,?)"
    elif kind == "audio_feature":
        statement = """
        AudioFeatures (
            Id, 
            DurationMS, 
            Key, 
            Mode, 
            TimeSignature, 
            Acousticness, 
            Danceability, 
            Energy, 
            Instrumentalness, 
            Liveness, 
            Loudness, 
            Speechiness, 
            Valence, 
            Tempo)
        VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?)
        """

    conn = sqlite3.connect('spotimine.sqlite')
    cur = conn.cursor()
    cur.executemany(f"INSERT INTO {statement}", records)
    conn.commit()
    conn.close()

def make_playlist(
    tempo, 
    valence, 
    danceability, 
    energy,
    duration_minutes,
    ignore_tempo,
    ignore_valence,
    ignore_energy,
    ignore_danceability
    ):
    '''Creates a playlist based off of the user's parameters and finds the best match. 
    The algorithm sets constraints based off of the user input initially and relaxes them
    if the resulting track list does not meet duration requirements.

    Parameters
    ----------
    tempo : float
        a number representing the parameter characteristic

    valence : float
        a number representing the parameter characteristic

    danceability : float 
        a number representing the parameter characteristic

    energy : float
        a number representing the parameter characteristic

    duration_minutes : float
        a number representing the parameter characteristic

    ignore_tempo : bool
        a boolean that controls whether the described parameter factors into creating the playlist

    ignore_valence : bool
        a boolean that controls whether the described parameter factors into creating the playlist

    ignore_energy : bool
        a boolean that controls whether the described parameter factors into creating the playlist

    ignore_danceability : bool
        a boolean that controls whether the described parameter factors into creating the playlist

    Returns
    -------
    results : list
        a list of tuples formatted (track name, track uri, and track duration in milliseconds) generated by the algorithm
    '''

    conn = sqlite3.connect('spotimine.sqlite')
    cur = conn.cursor()
    base_statement = """
        SELECT Name, SpotifyId, DurationMS
        FROM Tracks
	    JOIN AudioFeatures
	    ON Tracks.SpotifyId = AudioFeatures.Id
    """
    duration_ms = int(duration_minutes) * 60000
    tempo_range = make_range(tempo, 2)
    valence_range = make_range(valence, 0.025)
    energy_range = make_range(energy, 0.025)
    danceability_range = make_range(danceability, 0.025)

    results = []
    playlist_filled = check_playlist_length(results, duration_ms)

    while not playlist_filled: 
        final_statement  = ""
        condition_list = []

        if not ignore_tempo:
            tempo_clause = build_between_clause("Tempo", tempo_range)
            condition_list.append(tempo_clause)
            tempo_range = expand_range(tempo_range, 1)
        if not ignore_valence:
            valence_clause = build_between_clause("Valence", valence_range)
            condition_list.append(valence_clause)
            valence_range = expand_range(valence_range, 0.005)
        if not ignore_energy:
            energy_clause = build_between_clause("Energy",energy_range)
            condition_list.append(energy_clause)
            energy_range = expand_range(energy_range, 0.005)
        if not ignore_danceability:
            danceability_clause = build_between_clause("Danceability", danceability_range)
            condition_list.append(danceability_clause)
            danceability_range = expand_range(danceability_range, 0.005)
        
        final_statement = build_clause_with_condition(base_statement, build_condition_clause(condition_list))
        cur.execute(final_statement)
        results = cur.fetchall()

        if ignore_tempo and ignore_valence and ignore_energy and ignore_danceability:
            results = fill_playlist_from_random_songs(results, duration_ms)
        playlist_filled = check_playlist_length(results, duration_ms)
    conn.close()
    return results
        

def make_range(value, step):
    '''Creates a range based off of an initial value and a step that determines the width of the range
    Parameters
    ----------
    value : int
        The initial value to base the range off of
    
    step : float
        the distance from the initial value

    Returns
    -------
    a_range : list
        a list of a two numbers that comprise a range
    '''

    value = float(value)
    a_range = [value - step, value + step]
    return a_range

def expand_range(range_list, step):
    '''Expands two numbers of a range by the step value
    Parameters
    ----------
    range_list : list
        a list of two numbers to transform

    step : float
        the distance from the range to step

    Returns
    -------
    new_range : list
        the range list updated with steps
    '''

    new_range = [range_list[0] - step, range_list[1] + step]
    return new_range

def build_between_clause(column, range_list):
    '''Builds a SQL between clause given two numbers
    Parameters
    ----------
    column : str
        the table column 

    range_list : list
        a list of two numbers

    Returns
    -------
    clause : str
        the built SQL clause
    '''

    clause = f"{column} BETWEEN {range_list[0]} AND {range_list[1]}"
    return clause

def build_condition_clause(list_of_conditions):
    '''Builds a SQL WHERE clause given the conditions
    Parameters
    ----------
    list_of_conditions : list
        list of sql between clauses

    Returns
    -------
    condition_clause : str
        the built SQL clause
    '''

    condition_clause = "WHERE "
    if len(list_of_conditions) > 1:
        combined_clause = " AND ".join(list_of_conditions)
        condition_clause = condition_clause + " " + combined_clause
        return condition_clause
    elif len(list_of_conditions) == 1:
        condition_clause = condition_clause + list_of_conditions[0]
        return condition_clause
    else:
        condition_clause = "ORDER BY random()"
        return condition_clause

def build_clause_with_condition(statement, condition):
    '''Builds a SQL cause given a SELECT FROM statement and a conditional clause
    Parameters
    ----------
    statement : str
        The initial statement to concatenate

    condition : str
        a sql condition clause

    Returns
    -------
    new_statement : str
        the concatenated SQL statement 
    '''

    new_statement = statement + " " + condition
    return new_statement

def check_playlist_length(list_of_sql_results, duration_to_check):
    '''Checks the combined duration of all of the tracks provided by the list of sql results
    Parameters
    ----------
    list_of_sql_results : list
        a list of tuples representing tracks

    duration_to_check : int
        a number to check against the length of the sql duration results

    Returns
    -------
    bool
    '''
    
    current_length = 0
    if not list_of_sql_results:
        return False
    else:
        for sql_result in list_of_sql_results:
            current_length += float(sql_result[-1])
        return current_length > float(duration_to_check)

def fill_playlist_from_random_songs(list_of_sql_results, duration):
    '''Fills a playlist until the duration threshold is met
    Parameters
    ----------
    list_of_sql_results : list
        a list of tuples representing tracks

    duration : int
        a millisecond duration threshold that determines when to stop adding songs

    Returns
    -------
    randomized_playlist : list
        list of tuples representing tracks
    '''

    randomized_playlist = []
    cumulative_sum = 0
    for result in list_of_sql_results:
        if cumulative_sum < duration:
            randomized_playlist.append(result)
            cumulative_sum += result[-1]
        else:
            break
    return randomized_playlist

def make_histogram(column_name):
    '''Creates a plotly histogram based on the column name provided
    Parameters
    ----------
    column name : str
        the column name that determines which data to pull

    Returns
    -------
    fig_html : html
        a html graph generated by plotly
    '''

    x_values = get_analysis_values(column_name)
    histogram_data = go.Histogram(x = x_values, marker = dict(color = "#1DB954"))
    layout = go.Layout(title = f"{column_name.capitalize()} Distribution", plot_bgcolor="rgba(0, 0, 0, 0.2)")
    fig = go.Figure(data = histogram_data, layout = layout)
    fig.update_layout(
        title = {
            'y':0.9,
            'x':0.5,
            "xanchor" : "center",
            "yanchor": "top"
        },
        font=dict(
            family="'Montserrat', sans-serif",
            size=14,
            color="black"
        )
    )
    fig_html = fig.to_html(full_html = False)
    return fig_html

def get_analysis_values(column_name):
    '''Fetches a column's values from the SQLite database
    Parameters
    ----------
    column name : str
        the column name that determines which data to pull

    Returns
    -------
    values : list
        list of values retrieved from the database
    '''
    conn = sqlite3.connect('spotimine.sqlite')
    cur = conn.cursor()

    base_statement = "SELECT " + column_name
    table_join_statement = """
        FROM Tracks
	    JOIN AudioFeatures
	    ON Tracks.SpotifyId = AudioFeatures.Id
    """

    final_statement = base_statement + table_join_statement

    cur.execute(final_statement)
    fetched = cur.fetchall()
    values = [item[0] for item in fetched]
    conn.close()
    return values

def complete_setup(cache):
    '''Gets the current date and saves it to the cache
    Parameters
    ----------
    cache : dict
        a dict representation of the cache

    Returns
    -------
    none
    '''

    setup_complete_time = datetime.datetime.today().date()
    complete_time_as_str = setup_complete_time.strftime("%m/%d/%Y")
    cache["setup_complete"] = complete_time_as_str
    save_cache(cache)

def check_tracks_updated(cache):
    '''Checks whether or not the tracklist has been updated within 7 days
    Parameters
    ----------
    cache : dict
        a dict representation of the cache

    Returns
    -------
    bool
    '''
    if check_setup_complete(cache):
        date_complete = cache["setup_complete"]
        date_complete = datetime.datetime.strptime(date_complete, "%m/%d/%Y").date()

        current_date = datetime.datetime.today().date()

        days_since_last_update = (current_date - date_complete).days

        if days_since_last_update > 7:
            return False
        else:
            return True
    else:
        return False

def check_setup_complete(cache):
    '''Checks the cache to see if the setup_complete key is inside
    Parameters
    ----------
    cache : dict
        a dict representation of the cache

    Returns
    -------
    bool
    '''

    if "setup_complete" in cache.keys():
        return True
    else:
        return False

def load_cache():
    '''Tries to load a cache to read, if none is found one is created
    
    Parameters
    ----------
    none
    
    Returns
    -------
    cache : dict
        a dictionary containing the found cache
    '''

    try:
        cache_file = open(CACHE_FILE_NAME, 'r')
        cache_file_contents = cache_file.read()
        cache = json.loads(cache_file_contents)
        cache_file.close()
    except:
        cache = {}

    return cache

def save_cache(cache):
    '''Saves the contents passed in to the local cache
    
    Parameters
    ----------
    cache : dict
        a cache to save to
    
    Returns
    -------
    none
    '''

    cache_file = open(CACHE_FILE_NAME, 'w')
    contents_to_write = json.dumps(cache)
    cache_file.write(contents_to_write)
    cache_file.close()

